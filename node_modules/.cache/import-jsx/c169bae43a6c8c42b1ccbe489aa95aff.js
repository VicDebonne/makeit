"use strict";

const React = require("react");

const {
  useInput,
  useApp,
  Text,
  Box
} = require("ink"); // const BigText = require("ink-big-text");
// const Gradient = require("ink-gradient");


const CFonts = require('cfonts');

CFonts.say('Snake Deluxe', {
  font: '3d',
  // define the font face
  align: 'left',
  // define text alignment
  colors: ['red'],
  // define all colors
  background: 'backgroundColor',
  // define the background color, you can also use `backgroundColor` here as key
  letterSpacing: 1,
  // define letter spacing
  lineHeight: 1,
  // define the line height
  space: true,
  // define if the output text should have empty lines on top and on the bottom
  maxLength: '0',
  // define how many character can be on one line
  gradient: true,
  // define your two gradient colors
  independentGradient: false,
  // define if you want to recalculate the gradient for each new line
  transitionGradient: false,
  // define if this is a transition between colors directly
  env: 'node' // define the environment CFonts is being executed in

});

const App = () => {
  const {
    exit
  } = useApp();
  const [x, setX] = React.useState(1);
  const [y, setY] = React.useState(1);
  useInput((input, key) => {
    if (input === "q") {
      exit();
    }

    if (key.leftArrow) {
      setX(Math.max(1, x - 1));
    }

    if (key.rightArrow) {
      setX(Math.min(20, x + 1));
    }

    if (key.upArrow) {
      setY(Math.max(1, y - 1));
    }

    if (key.downArrow) {
      setY(Math.min(10, y + 1));
    }
  });
  return /*#__PURE__*/React.createElement(Box, {
    flexDirection: "column"
  }, /*#__PURE__*/React.createElement(Text, null, "Use arrow keys to move the icon. Press \"q\" to exit."), /*#__PURE__*/React.createElement(Box, {
    height: 12,
    paddingLeft: x,
    paddingTop: y
  }, /*#__PURE__*/React.createElement(Text, null, "\uD83D\uDE01")));
};

module.exports = App;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVpLmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwicmVxdWlyZSIsInVzZUlucHV0IiwidXNlQXBwIiwiVGV4dCIsIkJveCIsIkNGb250cyIsInNheSIsImZvbnQiLCJhbGlnbiIsImNvbG9ycyIsImJhY2tncm91bmQiLCJsZXR0ZXJTcGFjaW5nIiwibGluZUhlaWdodCIsInNwYWNlIiwibWF4TGVuZ3RoIiwiZ3JhZGllbnQiLCJpbmRlcGVuZGVudEdyYWRpZW50IiwidHJhbnNpdGlvbkdyYWRpZW50IiwiZW52IiwiQXBwIiwiZXhpdCIsIngiLCJzZXRYIiwidXNlU3RhdGUiLCJ5Iiwic2V0WSIsImlucHV0Iiwia2V5IiwibGVmdEFycm93IiwiTWF0aCIsIm1heCIsInJpZ2h0QXJyb3ciLCJtaW4iLCJ1cEFycm93IiwiZG93bkFycm93IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0EsTUFBTUEsS0FBSyxHQUFHQyxPQUFPLENBQUMsT0FBRCxDQUFyQjs7QUFDQSxNQUFNO0FBQUVDLEVBQUFBLFFBQUY7QUFBWUMsRUFBQUEsTUFBWjtBQUFvQkMsRUFBQUEsSUFBcEI7QUFBMEJDLEVBQUFBO0FBQTFCLElBQWtDSixPQUFPLENBQUMsS0FBRCxDQUEvQyxDLENBQ0E7QUFDQTs7O0FBQ0EsTUFBTUssTUFBTSxHQUFHTCxPQUFPLENBQUMsUUFBRCxDQUF0Qjs7QUFFQUssTUFBTSxDQUFDQyxHQUFQLENBQVcsY0FBWCxFQUEyQjtBQUMxQkMsRUFBQUEsSUFBSSxFQUFFLElBRG9CO0FBQ0Q7QUFDekJDLEVBQUFBLEtBQUssRUFBRSxNQUZtQjtBQUVFO0FBQzVCQyxFQUFBQSxNQUFNLEVBQUUsQ0FBQyxLQUFELENBSGtCO0FBR0Q7QUFDekJDLEVBQUFBLFVBQVUsRUFBRSxpQkFKYztBQUlNO0FBQ2hDQyxFQUFBQSxhQUFhLEVBQUUsQ0FMVztBQUtFO0FBQzVCQyxFQUFBQSxVQUFVLEVBQUUsQ0FOYztBQU1FO0FBQzVCQyxFQUFBQSxLQUFLLEVBQUUsSUFQbUI7QUFPRTtBQUM1QkMsRUFBQUEsU0FBUyxFQUFFLEdBUmU7QUFRRTtBQUM1QkMsRUFBQUEsUUFBUSxFQUFFLElBVGdCO0FBU0M7QUFDM0JDLEVBQUFBLG1CQUFtQixFQUFFLEtBVks7QUFVRTtBQUM1QkMsRUFBQUEsa0JBQWtCLEVBQUUsS0FYTTtBQVdFO0FBQzVCQyxFQUFBQSxHQUFHLEVBQUUsTUFacUIsQ0FZRTs7QUFaRixDQUEzQjs7QUFlQSxNQUFNQyxHQUFHLEdBQUcsTUFBTTtBQUNkLFFBQU07QUFBRUMsSUFBQUE7QUFBRixNQUFXbEIsTUFBTSxFQUF2QjtBQUNBLFFBQU0sQ0FBQ21CLENBQUQsRUFBSUMsSUFBSixJQUFZdkIsS0FBSyxDQUFDd0IsUUFBTixDQUFlLENBQWYsQ0FBbEI7QUFDQSxRQUFNLENBQUNDLENBQUQsRUFBSUMsSUFBSixJQUFZMUIsS0FBSyxDQUFDd0IsUUFBTixDQUFlLENBQWYsQ0FBbEI7QUFFQXRCLEVBQUFBLFFBQVEsQ0FBQyxDQUFDeUIsS0FBRCxFQUFRQyxHQUFSLEtBQWdCO0FBQ3JCLFFBQUlELEtBQUssS0FBSyxHQUFkLEVBQW1CO0FBQ2ZOLE1BQUFBLElBQUk7QUFDUDs7QUFFRCxRQUFJTyxHQUFHLENBQUNDLFNBQVIsRUFBbUI7QUFDZk4sTUFBQUEsSUFBSSxDQUFDTyxJQUFJLENBQUNDLEdBQUwsQ0FBUyxDQUFULEVBQVlULENBQUMsR0FBRyxDQUFoQixDQUFELENBQUo7QUFDSDs7QUFFRCxRQUFJTSxHQUFHLENBQUNJLFVBQVIsRUFBb0I7QUFDaEJULE1BQUFBLElBQUksQ0FBQ08sSUFBSSxDQUFDRyxHQUFMLENBQVMsRUFBVCxFQUFhWCxDQUFDLEdBQUcsQ0FBakIsQ0FBRCxDQUFKO0FBQ0g7O0FBRUQsUUFBSU0sR0FBRyxDQUFDTSxPQUFSLEVBQWlCO0FBQ2JSLE1BQUFBLElBQUksQ0FBQ0ksSUFBSSxDQUFDQyxHQUFMLENBQVMsQ0FBVCxFQUFZTixDQUFDLEdBQUcsQ0FBaEIsQ0FBRCxDQUFKO0FBQ0g7O0FBRUQsUUFBSUcsR0FBRyxDQUFDTyxTQUFSLEVBQW1CO0FBQ2ZULE1BQUFBLElBQUksQ0FBQ0ksSUFBSSxDQUFDRyxHQUFMLENBQVMsRUFBVCxFQUFhUixDQUFDLEdBQUcsQ0FBakIsQ0FBRCxDQUFKO0FBQ0g7QUFDSixHQXBCTyxDQUFSO0FBc0JBLHNCQUNJLG9CQUFDLEdBQUQ7QUFBSyxJQUFBLGFBQWEsRUFBQztBQUFuQixrQkFJSSxvQkFBQyxJQUFELGdFQUpKLGVBS0ksb0JBQUMsR0FBRDtBQUFLLElBQUEsTUFBTSxFQUFFLEVBQWI7QUFBaUIsSUFBQSxXQUFXLEVBQUVILENBQTlCO0FBQWlDLElBQUEsVUFBVSxFQUFFRztBQUE3QyxrQkFDSSxvQkFBQyxJQUFELHVCQURKLENBTEosQ0FESjtBQVdILENBdENEOztBQXdDQVcsTUFBTSxDQUFDQyxPQUFQLEdBQWlCakIsR0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgeyB1c2VJbnB1dCwgdXNlQXBwLCBUZXh0LCBCb3ggfSA9IHJlcXVpcmUoXCJpbmtcIik7XG4vLyBjb25zdCBCaWdUZXh0ID0gcmVxdWlyZShcImluay1iaWctdGV4dFwiKTtcbi8vIGNvbnN0IEdyYWRpZW50ID0gcmVxdWlyZShcImluay1ncmFkaWVudFwiKTtcbmNvbnN0IENGb250cyA9IHJlcXVpcmUoJ2Nmb250cycpO1xuXG5DRm9udHMuc2F5KCdTbmFrZSBEZWx1eGUnLCB7XG5cdGZvbnQ6ICczZCcsICAgICAgICAgICAgICAvLyBkZWZpbmUgdGhlIGZvbnQgZmFjZVxuXHRhbGlnbjogJ2xlZnQnLCAgICAgICAgICAgICAgLy8gZGVmaW5lIHRleHQgYWxpZ25tZW50XG5cdGNvbG9yczogWydyZWQnXSwgICAgICAgICAvLyBkZWZpbmUgYWxsIGNvbG9yc1xuXHRiYWNrZ3JvdW5kOiAnYmFja2dyb3VuZENvbG9yJywgIC8vIGRlZmluZSB0aGUgYmFja2dyb3VuZCBjb2xvciwgeW91IGNhbiBhbHNvIHVzZSBgYmFja2dyb3VuZENvbG9yYCBoZXJlIGFzIGtleVxuXHRsZXR0ZXJTcGFjaW5nOiAxLCAgICAgICAgICAgLy8gZGVmaW5lIGxldHRlciBzcGFjaW5nXG5cdGxpbmVIZWlnaHQ6IDEsICAgICAgICAgICAgICAvLyBkZWZpbmUgdGhlIGxpbmUgaGVpZ2h0XG5cdHNwYWNlOiB0cnVlLCAgICAgICAgICAgICAgICAvLyBkZWZpbmUgaWYgdGhlIG91dHB1dCB0ZXh0IHNob3VsZCBoYXZlIGVtcHR5IGxpbmVzIG9uIHRvcCBhbmQgb24gdGhlIGJvdHRvbVxuXHRtYXhMZW5ndGg6ICcwJywgICAgICAgICAgICAgLy8gZGVmaW5lIGhvdyBtYW55IGNoYXJhY3RlciBjYW4gYmUgb24gb25lIGxpbmVcblx0Z3JhZGllbnQ6IHRydWUsICAgICAgICAgICAgLy8gZGVmaW5lIHlvdXIgdHdvIGdyYWRpZW50IGNvbG9yc1xuXHRpbmRlcGVuZGVudEdyYWRpZW50OiBmYWxzZSwgLy8gZGVmaW5lIGlmIHlvdSB3YW50IHRvIHJlY2FsY3VsYXRlIHRoZSBncmFkaWVudCBmb3IgZWFjaCBuZXcgbGluZVxuXHR0cmFuc2l0aW9uR3JhZGllbnQ6IGZhbHNlLCAgLy8gZGVmaW5lIGlmIHRoaXMgaXMgYSB0cmFuc2l0aW9uIGJldHdlZW4gY29sb3JzIGRpcmVjdGx5XG5cdGVudjogJ25vZGUnICAgICAgICAgICAgICAgICAvLyBkZWZpbmUgdGhlIGVudmlyb25tZW50IENGb250cyBpcyBiZWluZyBleGVjdXRlZCBpblxufSk7XG5cbmNvbnN0IEFwcCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGV4aXQgfSA9IHVzZUFwcCgpO1xuICAgIGNvbnN0IFt4LCBzZXRYXSA9IFJlYWN0LnVzZVN0YXRlKDEpO1xuICAgIGNvbnN0IFt5LCBzZXRZXSA9IFJlYWN0LnVzZVN0YXRlKDEpO1xuXG4gICAgdXNlSW5wdXQoKGlucHV0LCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGlucHV0ID09PSBcInFcIikge1xuICAgICAgICAgICAgZXhpdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleS5sZWZ0QXJyb3cpIHtcbiAgICAgICAgICAgIHNldFgoTWF0aC5tYXgoMSwgeCAtIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkucmlnaHRBcnJvdykge1xuICAgICAgICAgICAgc2V0WChNYXRoLm1pbigyMCwgeCArIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkudXBBcnJvdykge1xuICAgICAgICAgICAgc2V0WShNYXRoLm1heCgxLCB5IC0gMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleS5kb3duQXJyb3cpIHtcbiAgICAgICAgICAgIHNldFkoTWF0aC5taW4oMTAsIHkgKyAxKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxCb3ggZmxleERpcmVjdGlvbj1cImNvbHVtblwiPlxuXHRcdFx0ey8qIDxHcmFkaWVudCBuYW1lPVwicmFpbmJvd1wiPlxuXHRcdFx0XHQ8QmlnVGV4dCB0ZXh0PVwic25ha2UgZGVsdXhlXCIvPlxuXHRcdFx0PC9HcmFkaWVudD4gKi99XG4gICAgICAgICAgICA8VGV4dD5Vc2UgYXJyb3cga2V5cyB0byBtb3ZlIHRoZSBpY29uLiBQcmVzcyBcInFcIiB0byBleGl0LjwvVGV4dD5cbiAgICAgICAgICAgIDxCb3ggaGVpZ2h0PXsxMn0gcGFkZGluZ0xlZnQ9e3h9IHBhZGRpbmdUb3A9e3l9PlxuICAgICAgICAgICAgICAgIDxUZXh0PvCfmIE8L1RleHQ+XG4gICAgICAgICAgICA8L0JveD5cbiAgICAgICAgPC9Cb3g+XG4gICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXBwO1xuIl19